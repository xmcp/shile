#coding=utf-8try:    from tkinter import *    from tkinter import messageboxexcept ImportError: #py2    from Tkinter import *    import tkMessageBox as messagebox    range=xrangetry:    import threading    def delay_redraw():        threading.Thread(target=redraw,args=(True,)).start()except ImportError: #py2    import thread    def delay_redtaw():        thread.start_new_thread(redraw,(True,))import timeimport randomfrom copy import deepcopytk=Tk()tk.title('2048')LEFT,RIGHT,UP,DOWN=0,1,2,3spawnlist=[1]*7+[2]*1scorevar=StringVar()score=0locked=Falsebg=['#BBADA1','#EDE4D9','#EDE0C7','#F3B174','#F7955F','#F87C5A',#32    '#F95D32','#EECF6B','#ECCD58','#EEC943','#EEC632','#EEC41F',#2048    '#FFFFFF','#FFFFFF','#FFFFFF','#FFFFFF']fg=['#FFFFFF','#786E65','#776F64','#FAF4EF','#F9F8F4','#F9F8F6',#32    '#F9F6F3','#F7F2E0','#FAF5EB','#F9F5EE','#F9F6F3','#F8F5F1',#2048    '#000000','#000000','#000000']g=[    [0,0,0,0],    [0,0,0,0],    [0,0,0,0],    [0,0,0,0]]label=[    [0,0,0,0],    [0,0,0,0],    [0,0,0,0],    [0,0,0,0]]gd=[    [StringVar(),StringVar(),StringVar(),StringVar()],    [StringVar(),StringVar(),StringVar(),StringVar()],    [StringVar(),StringVar(),StringVar(),StringVar()],    [StringVar(),StringVar(),StringVar(),StringVar()]]gackup=deepcopy(g)sackup=0def redraw(delay=False):    if delay:        time.sleep(0.1)    for y in range(4):        for x in range(4):            gd[y][x].set(str(2**g[y][x]) if g[y][x] else ' ')            label[y][x].config(background=bg[g[y][x]],                               foreground=fg[g[y][x]])def init_grid(*_):    if locked: return    global scorevar    global score    score=0    scorevar.set('得分: 0')    for y in range(4):        for x in range(4):            g[y][x]=0    g[random.choice(range(4))][random.choice(range(4))]=1    redraw()def spawn():    zeros=[(x,y) for x in range(4) for y in range(4) if g[y][x]==0]    try:        xnow,ynow=random.choice(zeros)        g[ynow][xnow]=random.choice(spawnlist)    except IndexError:        #lose        messagebox.showinfo('2048','您输了，得分%d'%score)        init_grid()def clearhelper(y,x):    def clearit(y,x):        if not locked: return        g[y][x]=0        redraw()    return lambda _:clearit(y,x)def doublehelper(y,x):    def doubleit(y,x):        if not locked: return        g[y][x]+=1        redraw()    return lambda _:doubleit(y,x)def save_grid(*_):    if locked: return    global gackup    global sackup    gackup=deepcopy(g)    sackup=score    scorevar.set('已保存: '+str(score))def load_grid(*_):    if locked: return    global score    global g    score=sackup    g=deepcopy(gackup)    redraw()    scorevar.set('已读取: '+str(score))def showhelp():    messagebox.showinfo(        '2048',        '''操作说明:方向键\t移动Enter\t跳过Ctrl-O\t读取Ctrl-S\t保存Ctrl-R\t重置Ctrl-L\t锁定''')def abandom(*_):    if locked: return    spawn()    redraw()def lock(*_):    global locked    locked=not locked    if locked:        lockbtn['relief']='sunken'    else:        lockbtn['relief']='raised'def go(position):    if locked: return    global score    before=[]    #crush    while g!=before:        before=deepcopy(g)        if position==UP:            for y in range(0,3):                for x in range(0,4):                    if g[y][x]==g[y+1][x]!=0:                        g[y][x]+=1                        g[y+1][x]=0                        score+=2**g[y][x]            for turn in range(3):                for y in range(0,3):                    for x in range(0,4):                        if g[y][x]==0 and g[y+1][x]!=0:                            g[y][x]=g[y+1][x]                            g[y+1][x]=0        elif position==DOWN:            for y in range(3,0,-1):                for x in range(0,4):                    if g[y][x]==g[y-1][x]!=0:                        g[y][x]+=1                        g[y-1][x]=0                        score+=2**g[y][x]            for turn in range(3):                for y in range(1,4):                    for x in range(0,4):                        if g[y][x]==0 and g[y-1][x]!=0:                            g[y][x]=g[y-1][x]                            g[y-1][x]=0        elif position==LEFT:            for y in range(0,4):                for x in range(0,3):                    if g[y][x]==g[y][x+1]!=0:                        g[y][x]+=1                        g[y][x+1]=0                        score+=2**g[y][x]            for turn in range(3):                for y in range(0,4):                    for x in range(0,3):                        if g[y][x]==0 and g[y][x+1]!=0:                            g[y][x]=g[y][x+1]                            g[y][x+1]=0        else: #position==RIGHT            for y in range(0,4):                for x in range(3,0,-1):                    if g[y][x]==g[y][x-1]!=0:                        g[y][x]+=1                        g[y][x-1]=0                        score+=2**g[y][x]            for turn in range(3):                for y in range(0,4):                    for x in range(1,4):                        if g[y][x]==0 and g[y][x-1]!=0:                            g[y][x]=g[y][x-1]                            g[y][x-1]=0    redraw()    #score    scorevar.set('得分: '+str(score))    spawn()    delay_redraw()lockbtn=Button(tk,text=' 锁定 ',command=lock)lockbtn.grid(row=0,column=0,pady=5)Label(tk,textvariable=scorevar).grid(row=0,column=1,columnspan=2)Button(tk,text=' 帮助 ',command=showhelp).grid(row=0,column=3,pady=5)for y in range(4):    for x in range(4):        label[y][x]=Label(tk,textvariable=gd[y][x],height=3,width=7,                          background='#BBADA1',foreground='#FFFFFF',font='Consolas')        label[y][x].grid(row=y+1,column=x)        label[y][x].bind('<Triple-Button-3>',clearhelper(y,x))#hehe        label[y][x].bind('<Triple-Button-2>',doublehelper(y,x))#hehetk.bind('<Key-Left>',lambda _:go(LEFT))tk.bind('<Key-Right>',lambda _:go(RIGHT))tk.bind('<Key-Up>',lambda _:go(UP))tk.bind('<Key-Down>',lambda _:go(DOWN))tk.bind('<Key-Return>',abandom)tk.bind('<Control-r>',init_grid)tk.bind('<Control-s>',save_grid)tk.bind('<Control-o>',load_grid)tk.bind('<Control-l>',lock)init_grid()mainloop()